#summary ActiveJDBC Validation framework

= Introduction =
ActiveJDBC has a validation framework that is somewhat reminiscent of !ActiveRecord validation. The validation rules in ActiveJDBC are described in a model definition in a declarative way and are self-explanatory

=Validation of attribute presence=
In order to add any validation, a model will declare  a static bloc at the top of a class definition, and invoke all validation declaration inside this block:
{{{
public class Person extends Model {
    static{
        validatePresenceOf("first_name", "last_name");
    }    
}
}}}
The method `Model.validatePresenceOf()` takes a vararg of strings, which allows to specify a list of attribute names (column names) in one line of code. 


=Triggering of validation=
triggering of validations happens under three conditions:
  * Call `Model.validate()` method
  * Call `Model.save()` method
  * Call `Model.saveIt()` method

The semantic difference of `save()` and `saveIt()` methods is described on the [RecordCreation] page.


=Consuming validation messages=

After the validation triggered, you can retrieve all messages from a model as a collection:

{{{
//...trigger validation

Map<String, String> errors = myPerson.errors();
String firstNameError = errors.get("first_name");
}}}

As you can imagine, it is very easy to write web applications with form validation using this ActiveJDBC validations.


=Override default message=
Message overriding is easy with the help of a method `message()`:
{{{
public class Person extends Model {
    static{
        validatePresenceOf("first_name", "last_name").message("this value is missing");
    }    
}
}}}

=Customized messages for different attributes=

You can call method `validatePresenceOf().message()` multiple times, providing different attribute names as well as different messages:

{{{
public class Person extends Model {
    static{
        validatePresenceOf("first_name").message("Please, provide your first name");
        validatePresenceOf("last_name").message("Please, provide your last name");
    }    
}
}}}

=Validation of numericality=
ActiveJDBC like ActiveRecord also provides other validators, for instance:
{{{
public class Account extends Model {
    static{
        validateNumericalityOf("amount", "account", "total");
    }
}
}}}

Like the `validatePresenseOf()`, this method also takes in a vararg of strings, which allows to specify a list of attribute names that should have a numeric format. 

=Validation of numericality with additional properties=

When checking numericality of an attribute, you can have a finer control, including specifying that it could be `null`, providing a range and a custom  message. In fact, all validators allow for custom message.

{{{
public class Account extends Model {
    static{
        validateNumericalityOf("total")
                .allowNull(true).greaterThan(0)
                .lessThan(100).onlyInteger()
                .message("incorrect 'total'");
    }
}
}}}
Again, ActiveJDBC is using [http://martinfowler.com/bliki/FluentInterface.html Fluent Interfaces] technique, as in many other places. 