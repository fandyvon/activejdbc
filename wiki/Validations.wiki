#summary ActiveJDBC Validation framework
<wiki:toc max_depth="2" />

= Introduction =
ActiveJDBC has a validation framework that is somewhat reminiscent of !ActiveRecord validation. The validation rules in ActiveJDBC are described in a model definition in a declarative way:

=Validation of attribute presence=
In order to add any validation, a model will declare  a static bloc at the top of a class definition, and invoke all validation declaration inside this block:
{{{
public class Person extends Model {
    static{
        validatePresenceOf("first_name", "last_name");
    }    
}
}}}
The method `Model.validatePresenceOf()` takes a vararg of strings, which allows to specify a list of attribute names (column names) in one line of code. 


=Triggering of validation=
triggering of validations happens under these conditions:
  * Call `Model.validate()` method (will not throw exception)
  * Call `Model.save()` method (will not throw exception)
  * Call `Model.saveIt()` method (will throw exception)
  * Call `Model.createIt()` method (will throw exception)

The semantic difference of `save()` and `saveIt()` methods is described on the [RecordCreation] page.


=Consuming validation messages=

After the validation triggered, you can retrieve all messages from a model as a collection:

{{{
//...trigger validation

Map<String, String> errors = myPerson.errors();
String firstNameError = errors.get("first_name");
}}}

As you can imagine, it is very easy to write web applications with form validation using this ActiveJDBC validations.


=Override default message=
Message overriding is easy with the help of a method `message()`:
{{{
public class Person extends Model {
    static{
        validatePresenceOf("first_name", "last_name").message("this value is missing");
    }    
}
}}}

=Usage in a web application=
This is a pseudo-code of a web application controller where a form was submitted:

{{{

public void savePerson(){
   Map params = ... // this is a map of HTML form submitted from a web page
   Person p = Person();
   p.fromMap(params); //The model will only pluck values that correspond to it's attribute names
   
   if(p.save()){
      //render success page
   }else{
      renderSamePageWithErrors(params, p.errors());// this is web framework specific, only pseudo-code
   }
}
}}}
As you can see, it is trivial to integrate ActiveJDBC into a web application.

=Customized messages for different attributes=

You can call method `validatePresenceOf().message()` multiple times, providing different attribute names as well as different messages:

{{{
public class Person extends Model {
    static{
        validatePresenceOf("first_name").message("Please, provide your first name");
        validatePresenceOf("last_name").message("Please, provide your last name");
    }    
}
}}}

=Validation of numericality=
ActiveJDBC like !ActiveRecord also provides other validators, for instance:
{{{
public class Account extends Model {
    static{
        validateNumericalityOf("amount", "account", "total");
    }
}
}}}

Like the `validatePresenseOf()`, this method also takes in a vararg of strings, which allows to specify a list of attribute names that should have a numeric format. 

=Validation of numericality with additional properties=

When checking numericality of an attribute, you can have a finer control, including specifying that it could be `null`, providing a range and a custom  message. In fact, all validators allow for custom message.

{{{
public class Account extends Model {
    static{
        validateNumericalityOf("total")
                .allowNull(true).greaterThan(0)
                .lessThan(100).onlyInteger()
                .message("incorrect 'total'");
    }
}
}}}
Again, ActiveJDBC is using [http://martinfowler.com/bliki/FluentInterface.html Fluent Interfaces] technique, as in many other places. 

=Range validator=
Besides numeric validation, there is also a specific range validator:
{{{
public class Temperature extends Model {
    static{
        int min = 0, max = 100;
        validateRange("temp", min, max).message("temperature cannot be less than " + min + " or more than " + max);
    }
}
}}}
Although you can use either numeric or range validators for range, in some cases range validator will have a more concise syntax than numeric one.


=Email validator=
The email validator exists to check a proper format of email (it does not check if email actually exists!)
{{{

public class User extends Model {
    static{
        validateEmailOf("email");
    }
}
}}}

=Regular expressions validator=
You can probably guess, that the email validator is a special case of a regular expression validator:

{{{
public class User extends Model {
    static{
        validateRegexpOf("email", "\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}\\b");
    }
}
}}}
This validator provides enough freedom to developers who know regular expressions well :)

=Custom validators=
If all else fails, and ActiveJDBC does not provide a validator you want, you can implement a Validator interface:
{{{
public interface Validator {
    void validate(Model m);
    void setMessage(String message);
}
}}}
or better yet, !ValidatorAdapter:
{{{

public class CustomValidator extends ValidatorAdapter{
   void validate(Model m){
      //perform whatever validation logic, then add errors to model if validation did not pass:
      m.addError("custom_error", "message.key.from.resource.bundle");
    }
}
}}}

Once you have a custom validation, you can register it with a model like this:

{{{
CustomValidator cv = new CustomValidator();
Person.addValidator(cv);
}}}

after a validation, you can retrieve an error like this:
{{{
Person p = ...
p.save();
String errorMessage = p.errors().get("custom_error");
}}}

Validators are executed during validation in the order they were added to the model. The `validate()` method is called from `save()` and `saveIt()`

=Conclusion=
ActiveJDBC provides a number of built in validators and also allows to register custom validators.


back to [Features]