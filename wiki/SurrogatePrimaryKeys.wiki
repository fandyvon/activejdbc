#summary How to understand usage and generation of surrogate primary keys

<wiki:toc max_depth="2" />
= Introduction =

ActiveJDBC, like !ActiveRecord relies on the surrogate primary keys. Description is found here:[http://en.wikipedia.org/wiki/Surrogate_key].
A surrogate key is not generated by ActiveJDBC. Unlike Hibernate, it does not (currently) have any generators for the keys and relies fully on DBMS solution to do this. Depending on a DB implementation, you can use various techniques to achieve this goal.

=MySQL usage=
MySQL probably has the best support for this feature, since it has a direct syntax for them:
{{{
CREATE TABLE people (
  id  INT(11) DEFAULT NULL AUTO_INCREMENT PRIMARY KEY, 
  first_name VARCHAR(56), 
  last_name VARCHAR(56), 
  dob DATE, 
  graduation_date DATE, 
  created_at DATETIME, 
  updated_at DATETIME);
}}}

This example is taken from ActiveJDBC tests. The surrogate PK {{{id}}} will be properly incremented by MySQL.

Example:

{{{
Person p = new Person();
p.getId(); //<<< ===== returns null
p.set("first_name", "Igor").set("last_name", "Polevoy").saveIt();
p.getId(); //<<< ===== returns non-null value, type depends on DBMS driver conversion
}}}


=Oracle usage with sequences and triggers=
In Oracle things a bit more involved. The strategy is to create a sequence to generate numbers, and trigger to enter these numbers into the *id* column when inserting and not doing this when updating. In other words, if there an insert or update statement without this value, trigger provides one from a sequence, and if one is already provided by the SQL statement, trigger just ignores it. 

{{{
CREATE TABLE people (
   id  NUMBER NOT NULL, 
   name VARCHAR(56), 
   last_name VARCHAR(56), 
   dob DATE, 
   graduation_date DATE, 
   created_at TIMESTAMP, 
   updated_at TIMESTAMP)

ALTER TABLE people ADD CONSTRAINT people_pk PRIMARY KEY ( id )

CREATE SEQUENCE people_seq START WITH 1 INCREMENT BY 1

CREATE OR REPLACE TRIGGER people_trigger
    BEFORE INSERT ON people REFERENCING
    NEW AS new
    OLD AS old
    FOR EACH ROW
    begin
select coalesce(:new.id, people_seq.nextval) into :new.id from dual;
end;
}}}

This SQL creates a DB structure that allows ActiveJDBC behave exactly the same as with MySQL:

{{{
Person p = new Person();
p.getId(); //<<< ===== returns null
p.set("first_name", "Igor").set("last_name", "Polevoy").saveIt();
p.getId(); //<<< ===== returns non-null value, type depends on DBMS driver conversion
}}}

=Oracle usage with sequences and no triggers=
In order to reduce amount of SQL to generate your schema, you can adapt a simpler strategy: create only one sequence and use it as a source of generated values for all tables:


{{{
CREATE TABLE people (
   id  NUMBER NOT NULL, 
   name VARCHAR(56), 
   last_name VARCHAR(56), 
   dob DATE, 
   graduation_date DATE, 
   created_at TIMESTAMP, 
   updated_at TIMESTAMP)

ALTER TABLE people ADD CONSTRAINT people_pk PRIMARY KEY ( id )

CREATE SEQUENCE main_seq START WITH 1 INCREMENT BY 1
}}}
When defining a model, however, you will need to provide this piece of information to all models where you intend to use this sequence:
{{{
@IdGenerator("main_seq.nextVal")
public class Person extends Model{}
}}}

The usage code, behavior and expectations will be exactly the same with this strategy. AS you can see, this seems to be simpler than using triggers, but it has a drawback. Since the same sequence will be used across multiple tables, the number values in a single table could (will) be out of sequence. But.. since this is a surrogate key anyway, it does not matter.


=PosgreSQL usage=
PosgreSQL has a capability similar to that of MySQL, but different syntax - no sequences are required:

{{{
CREATE TABLE people (
   id SERIAL PRIMARY KEY, 
   name VARCHAR(56) NOT NULL, 
   last_name VARCHAR(56), 
   dob DATE, graduation_date DATE, 
   created_at TIMESTAMP, 
   updated_at TIMESTAMP);
}}}

The keyword 'SERIAL' in PostgrerSQL does the same as MuSQL's AUTO_INCTREMENT


Back to [Features]