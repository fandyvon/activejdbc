#summary How to understand usage and generation of surrogate primary keys

<wiki:toc max_depth="2" />
= Introduction =

ActiveJDBC, like !ActiveRecord relies on the surrogate primary keys. Description is found here:[http://en.wikipedia.org/wiki/Surrogate_key].
A surrogate key is not generated by ActiveJDBC. Unlike Hibernate, it does not (currently) have any generators for the keys and relies fully on DBMS solution to do this. Depending on a DB implementation, you can use various techniques to achieve this goal.



= Key name =
By convention, the primary key name is `id`. If your table has a surrogate primary key column with a name `id`, you do not have to do anything.


=Key Value=
When a new object of a model is created, the value of the ID is obviously `null`. 
When an object is looked up from a database, the ID value is populated to appropriately as any other attributes. 

When a `save()` method is called, it will generate either an "INSERT" or "UPDATE" query, based on a value of the ID attribute. If the ID == null, it will assume that this model represents a new record and will generate an INSERT, of the ID is not null, then it will generate an UPDATE query. 

A developer could set an ID manually, but this is not its typical usage.


=Override primary key=

If your table cannot provide a primary key column named `id` (for instance due to corporate naming standards), you can override it with `@IdName` annotation. 

Example: let's say you have a table PEOPLE:
{{{
CREATE TABLE people (
  person_id int(11) NOT NULL AUTO_INCREMENT,
  first_name              VARCHAR(124),
  last_name               VARCHAR(124),
)
}}}

You will then put annotation on the model:
{{{
@IdName("person_id")
public class Person extends Model{}
}}}

This way, the model will know to work with column `person_id` and not `id` as a primary key.



=MySQL usage=
MySQL probably has the best support for this feature, since it has a direct syntax for them:
{{{
CREATE TABLE people (
  id  INT(11) DEFAULT NULL AUTO_INCREMENT PRIMARY KEY, 
  first_name VARCHAR(56), 
  last_name VARCHAR(56), 
  dob DATE, 
  graduation_date DATE, 
  created_at DATETIME, 
  updated_at DATETIME);
}}}

This example is taken from ActiveJDBC tests. The surrogate PK {{{id}}} will be properly incremented by MySQL.

Example:

{{{
Person p = new Person();
p.getId(); //<<< ===== returns null
p.set("first_name", "Igor").set("last_name", "Polevoy").saveIt();
p.getId(); //<<< ===== returns non-null value, type depends on DBMS driver conversion
}}}


=Oracle usage with sequences and triggers=
In Oracle things a bit more involved. The strategy is to create a sequence to generate numbers, and trigger to enter these numbers into the *id* column when inserting and not doing this when updating. In other words, if there an insert or update statement without this value, trigger provides one from a sequence, and if one is already provided by the SQL statement, trigger just ignores it. 

{{{
CREATE TABLE people (
   id  NUMBER NOT NULL, 
   name VARCHAR(56), 
   last_name VARCHAR(56), 
   dob DATE, 
   graduation_date DATE, 
   created_at TIMESTAMP, 
   updated_at TIMESTAMP)

ALTER TABLE people ADD CONSTRAINT people_pk PRIMARY KEY ( id )

CREATE SEQUENCE people_seq START WITH 1 INCREMENT BY 1

CREATE OR REPLACE TRIGGER people_trigger
    BEFORE INSERT ON people REFERENCING
    NEW AS new
    OLD AS old
    FOR EACH ROW
    begin
select coalesce(:new.id, people_seq.nextval) into :new.id from dual;
end;
}}}

This SQL creates a DB structure that allows ActiveJDBC behave exactly the same as with MySQL:

{{{
Person p = new Person();
p.getId(); //<<< ===== returns null
p.set("first_name", "Igor").set("last_name", "Polevoy").saveIt();
p.getId(); //<<< ===== returns non-null value, type depends on DBMS driver conversion
}}}

=Oracle usage with sequences and no triggers=
In order to reduce amount of SQL to generate your schema, you can adapt a simpler strategy: create only one sequence and use it as a source of generated values for all tables:


{{{
CREATE TABLE people (
   id  NUMBER NOT NULL, 
   name VARCHAR(56), 
   last_name VARCHAR(56), 
   dob DATE, 
   graduation_date DATE, 
   created_at TIMESTAMP, 
   updated_at TIMESTAMP)

ALTER TABLE people ADD CONSTRAINT people_pk PRIMARY KEY ( id )

CREATE SEQUENCE main_seq START WITH 1 INCREMENT BY 1
}}}
When defining a model, however, you will need to provide this piece of information to all models where you intend to use this sequence:
{{{
@IdGenerator("main_seq.nextVal")
public class Person extends Model{}
}}}

The usage code, behavior and expectations will be exactly the same with this strategy. As you can see, this seems to be simpler than using triggers, but it has a drawback. Since the same sequence will be used across multiple tables, the number values in a single table could (will) be out of sequence. But.. since this is a surrogate key anyway, it does not matter.


=PostgreSQL usage=
PostgreSQL has a capability similar to that of MySQL, but different syntax - no sequences are required:

{{{
CREATE TABLE people (
   id SERIAL PRIMARY KEY, 
   name VARCHAR(56) NOT NULL, 
   last_name VARCHAR(56), 
   dob DATE, graduation_date DATE, 
   created_at TIMESTAMP, 
   updated_at TIMESTAMP);
}}}

The keyword 'SERIAL' in PostgreSQL does the same as MySQL's AUTO_INCREMENT



=Composite Primary Keys=
Like !ActibveRecord, ActiveJDBC does not support composite primary keys. However, this does not mean that you cannot use AJ on tables with declared composite PKs. All it means is that AJ does not provide any constraint checks, and relies on the DB for that. It would still require to have a surrogate PK column in a table if you want to do inserts and updates, but will not require it if all you need is select. 



Back to [Features]