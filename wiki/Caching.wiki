#summary ActiveJDBC Caching
<wiki:toc max_depth="2" />
= Introduction =

Caching is an integral part of every major system, It improves performance, reduces IO and makes overall user experience more pleasurable. Caching in ActiveJDBC works on the level of query and creation of model instances. For instance, the call:

{{{
List<Library> illLibs = Library.where("state = ?", "IL");
}}}
might call into DB, or a result can come from cache, depending how cache and specifically model `Library` was configured

=Cache annotation=
ActiveJDBC provides annotation to specify queries against which tables will be cached:

{{{
@Cached
public class Library extends Model {}
}}}

As in other cases, this is a declaration that marks a model as "cachable". If you enable logging (by providing a system property `activejdbc.log`), you will see extensive output from ActiveJDBC, similar to this:
{{{
3076 [main] INFO activejdbc.DB - Query: "SELECT * FROM libraries WHERE id = ?", with parameters: [1], took: 0 milliseconds
3076 [main] INFO activejdbc.cache.QueryCache - HIT, "SELECT * FROM libraries WHERE id = ?", with parameters: [1]
3077 [main] INFO activejdbc.DB - Query: "INSERT INTO libraries (address, state, city) VALUES (?, ?, ?)", with parameters: [123 Pirate Street, CA, Bloomington], took: 1 milliseconds
3077 [main] INFO activejdbc.cache.QueryCache - table cache purged for: libraries
3077 [main] INFO activejdbc.cache.QueryCache - table cache purged for: books
3077 [main] INFO activejdbc.cache.QueryCache - MISS, "SELECT * FROM libraries WHERE id = ?", with parameters: [1]
3078 [main] INFO activejdbc.DB - Query: "SELECT * FROM libraries WHERE id = ?", with parameters: [1], took: 0 milliseconds
}}}

=Cache Configuration (AJ Version 1.1 and above)=

The new cache configuration includes providing a cache manager class name in the  file `activejdbc.properties`. This file will have to be on the root of classpath.
Here is one example:

{{{
#inside file: activejdbc.properties
# use OSCache
cache.manager=org.javalite.activejdbc.cache.OSCacheManager
#or EHCache:
#cache.manager=org.javalite.activejdbc.cache.EHCacheManager
}}}

Here two things happen: 1. Cache in general is enabled (it is not enabled even if you have @Cached annotations on classes), and 2. AJ will be using OSCacheManager as implementation of cache. 


=Cache Configuration (AJ Version 1.0 and below)=

In order to enable caching (even if you have @Cache annotations!) you have to have a property file on the classpath called `activejdbc.properties`. This file needs to have one line of code:
{{{
#inside file: activejdbc.properties
cache.enabled=true
}}}





Without this file with one property no caching will be turned on.
=Automatic cache purging=

If you examine the log from above, you will see that after an insert statement into the "LIBRARIES" table, the system is purging cache related to this table, as well as "BOOKS" table. ActiveJDBC does this since the cache in memory might be potentially of out sync with the data in the DB, and hence will be purged. Related tables' caches are also purged. Since there exists relationship: library has many books,  the books cache could also be stale, and this is a reason why a table "BOOKS" purged as well. 

=Manual cache purging=

If you want to manually purge caches (in cases you make destructive data operations outside Model API), you can do so:
{{{
activejdbc.cache.QueryCache.instance().purgeTableCache("books");
}}}

or:
{{{
Books.purgeCache();
}}}


=What to cache=
While caching is a complex issue, I can suggest caching predominantly lookup data. Lookup data is something that does not change very frequently. If you start caching everything, you might run into a problem of cache thrashing where you fill cache with data, and purge it soon after, without having a benefit of caching. Instead of improving performance, you will degrade it with extra CPU, RAM and IO (is cluster is configured) used and little or no benefit of having a cache in the first place. 

=Things to be careful about=
ActiveJDBC manages caches for models and  their respective relationships (read above), but in some cases you will use a query that ties together unrelated models:
{{{
List<User> users = User.where("id not in (select user_id from restricted_users)");
}}}

If there exists a model User that is cached, and model RestrictedUser, and these tables/models have no relationship, then the line above could present a logical problem. If you execute the line above, and later change content of RESTRICTED_USERS table, then the query above will not see the change, and will return stale data. Developers need to be aware of this, and deal with  these issues carefully. Whenever you change data in RESTRICTED_USERS table, please purge User model:
{{{
User.purgeCache();
}}}


=Cache providers=
ActiveJDBC has a simple plugin framework for adding cache providers. Currently supports:
  *  [http://www.opensymphony.com/oscache/ OSCache]. OSCache is a known, well tested cache solution for Java, which supports many ways to cache data(memory, file system, clustering, etc.). For more information, see their documentation [http://www.opensymphony.com/oscache/wiki/Documentation.html OSCache Documentation].
  * [http://ehcache.org/ EHCache]. EHCache is high performance popular open source project. For documentation, please refer to: [http://ehcache.org/documentation]

=OSCache configuration for cluster=
In case your application is deployed in a cluster, and you use caching in ActiveJDBC, you will need to configure clustering. This is necessary so that when your application invokes a destructive action, a proper purge events are distributed in a cluster. OSCache is very efficient, as it does not share the actual data across cluster. Each cluster will have its own caches based on a usage on that cluster. Whenever a purge event is generated on one node in the cluster, this event will be broadcast by OSCache to other nodes, effectively blowing the same caches across entire cluster. These events are lightweight and very fast (UDP, using JGroups).
For more information on configuration of OSCache clustering, look here:[http://www.opensymphony.com/oscache/wiki/Clustering.html]

==Example of clustering configuration for OSCache==
Contents of file: *oscache.properties* (also found in root of classpath)
{{{
cache.cluster.properties =
TCP(start_port=7800;loopback=true):
TCPPING(initial_hosts=localhost[7800];
port_range=5;timeout=3000;
num_initial_members=3;up_thread=true;down_thread=true):
MERGE2(min_interval=5000;max_interval=10000):
FD(shun=true;timeout=2500;max_tries=5;up_thread=true;down_thread=true):
VERIFY_SUSPECT(timeout=1500;down_thread=false;up_thread=false):
pbcast.NAKACK (down_thread=true;up_thread=true;gc_lag=100;retransmit_timeout=3000):
pbcast.STABLE(desired_avg_gossip=20000;down_thread=false;up_thread=false):
pbcast.GMS(join_timeout=5000;join_retry_timeout=2000;shun=false;
print_local_addr=false;down_thread=true;up_thread=true)
}}}

On line 3, you see the parameter initial_hosts with only one value: `localhost[7800]`. This means that in this specific case, more than one node was running on the same "localhost" (and listened on port 7800). However, if you need to run nodes on different hosts, you configuration will look similar to this:
{{{
somehost1[7800],somehost2[7800],somehost3[7800];
}}}
For more information, refer to OSCache   [http://www.opensymphony.com/oscache/wiki/Clustering.html]documentation and JGroups documentation: http://www.jgroups.org/manual/html_single/index.html#d0e2510


Back to [Features]