=Introduction=
One to many associations are pretty common in relational schemas. Examples are: university has students, library has books, etc. There are two sides to a one to many association, the "parent" *has a* "child" and a "child" *belongs to* "parent". 

ActiveJDBC supports this type of a relationship  in two ways: 1. Inferred and 2. Overridden

=Database schema=
This is a database schema (for MySQL):
{{{
DROP TABLE IF EXISTS users;
CREATE TABLE users (
id  int(11) DEFAULT NULL auto_increment PRIMARY KEY, 
first_name VARCHAR(56), 
last_name VARCHAR(56), 
email VARCHAR(56));

INSERT INTO users VALUES(1, 'Marilyn', 'Monroe', 'mmonroe@yahoo.com');
INSERT INTO users VALUES(2, 'John', 'Doe', 'jdoe@gmail.com');


DROP TABLE IF EXISTS addresses;
CREATE TABLE addresses (
id  int(11) DEFAULT NULL auto_increment PRIMARY KEY, 
address1 VARCHAR(56), 
address2 VARCHAR(56), 
city VARCHAR(56), 
state VARCHAR(56), 
zip VARCHAR(56), 
user_id int(11));

INSERT INTO addresses VALUES(1, '123 Pine St.', 'apt 31', 'Springfield', 'IL', '60606', 1);
INSERT INTO addresses VALUES(2, '456 Brook St.', 'apt 21', 'Springfield', 'IL', '60606', 1);
INSERT INTO addresses VALUES(3, '23 Grove St.', 'apt 32', 'Springfield', 'IL', '60606', 1);
INSERT INTO addresses VALUES(4, '143 Madison St.', 'apt 34', 'Springfield', 'IL', '60606', 2);
INSERT INTO addresses VALUES(5, '153 Creek St.', 'apt 35', 'Springfield', 'IL', '60606', 2);
INSERT INTO addresses VALUES(6, '163 Gorge St.', 'apt 36', 'Springfield', 'IL', '60606', 2);
INSERT INTO addresses VALUES(7, '173 Far Side.', 'apt 37', 'Springfield', 'IL', '60606', 2);
}}}

=Models=

User:
{{{
public class User extends Model {}
}}}

Address:
{{{
public class User extends Model {}
}}}

As you can see from the schema, the table ADDRESS, has a column called {{{user_id}}}. Just because table ADDRESS has this column, ActiveJDBC assumes that there is a one to many relationship here, and makes special arrangements.
By doing so, the framework (internally) creates two associations (User has many Address(es)) and Adress belongs to User.

The design of ActiveJDBC tries to make usage of the APIs as clean and concise as possible. 

=How to get children=
Nothing can be simpler:
{{{
List<Address> addresses = user.getAll(Address.class);
}}}

Here the Adress.class needs to be passed in because a model User might have many other relationships with models other than Address.class. 


=How to get Parent=

{{{
User user = address.parent(User.class);
}}}
Here, we have to pass a {{{User.class}}} to indicate which parent type we want. This is because a model could have multiple parents (belong to more than one parent)



=Override Conventions=
In cases where a surrogate foreign key is already present and has a name that does not follow the ActiveJDBC conventions, you could easily override it like this:
{{{
@BelongsTo(parent = User.class, foreignKeyName = "usr_id")
public class Address extends Model {}
}}}
The @BelongsTo annotation will ensure that API on both ends will work. ActiveJDBC does not have annotation @HasMany, since I believe this would be redundant. 

=Foreign Key=
The Foreign Key in the ADDRESS table does not have to be a real Foreign Key constraint. ActiveJDBC(much like ActiveRecord) does not check for it's presence. As long as there is a column named according to this convention, ActiveJDBC assumes that there is a relationship. It does not hurt to have the actual constraint in the DB if you are using other means of accessing data. 


=Conclusion=
ActibeJDBC makes it very easy to setup associations. If you work with a new schema, you just need to follow conventions (by including a logical foreign key into a child table). 
In cases when you already have an existing schema, ActiveJDBC allows to override conventions with simple annotations
