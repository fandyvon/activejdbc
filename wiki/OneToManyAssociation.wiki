#summary How to use one to many associations with ActiveJDBC
<wiki:toc max_depth="2" />

=Introduction=
One to many associations are pretty common in relational schemas. Examples are: university has students, library has books, etc. There are two sides to a one to many association, the "parent" *has a* "child" and a "child" *belongs to* "parent". 

ActiveJDBC supports this type of a relationship  in two ways: 1. Inferred and 2. Overridden

=Database schema=
This is a database schema (for MySQL):
{{{
CREATE TABLE users (
id  int(11) DEFAULT NULL auto_increment PRIMARY KEY, 
first_name VARCHAR(56), 
last_name VARCHAR(56), 
email VARCHAR(56));


CREATE TABLE addresses (
id  int(11) DEFAULT NULL auto_increment PRIMARY KEY, 
address1 VARCHAR(56), 
address2 VARCHAR(56), 
city VARCHAR(56), 
state VARCHAR(56), 
zip VARCHAR(56), 
user_id int(11));
}}}

=Models=

User:
{{{
public class User extends Model {}
}}}

Address:
{{{
public class User extends Model {}
}}}

As you can see from the schema, the table ADDRESSES, has a column called {{{user_id}}}. Just because table ADDRESSES has this column, ActiveJDBC assumes that there is a one to many relationship here, and makes special arrangements.
By doing so, the framework (internally) creates two associations (User has many Address(es) and Address belongs to User).

The design of ActiveJDBC tries to make usage of the APIs as clean and concise as possible. 

=How to get children=
Nothing can be simpler:
{{{
List<Address> addresses = user.getAll(Address.class);
}}}

Here the Address.class needs to be passed in because a model User might have many other relationships with models other than Address.class. 


=How to get Parent=

{{{
User user = address.parent(User.class);
}}}
Here, we have to pass a {{{User.class}}} to indicate which parent type we want. This is because a model could have multiple parents (belong to more than one parent)

=Deleting Parent=
A simple way to delete a parent is:
{{{
User u = address.parent(User.class);

u.delete();
}}}

If you have a referential integrity in your DB and table ADDRESSES has records associated with this user, then you will get an exception from DB. If you do not have child records, this user will be deleted. If you have records in the ADDRESSES table and no referential integrity constraint, the user will be deleted and you will have orphan records in the ADDRESSES table. In order to delete a user and all it's child records, execute this method:
{{{
u.deleteCascade();
}}}

This method will walk over all parent/child relationships and delete all user and all child records associated with it

=Override Conventions=
In cases where a surrogate foreign key is already present and has a name that does not follow the ActiveJDBC conventions, you could easily override it like this:
{{{
@BelongsTo(parent = User.class, foreignKeyName = "usr_id")
public class Address extends Model {}
}}}
The !@BelongsTo annotation will ensure that API on both ends will work. ActiveJDBC does not have annotation !@HasMany, since I believe this would be redundant. 

=Foreign Key=
The Foreign Key in the ADDRESSES table does not have to be a real Foreign Key constraint. ActiveJDBC(much like ActiveRecord) does not check for it's presence. As long as there is a column named according to this convention, ActiveJDBC assumes that there is a relationship. It does not hurt to have the actual constraint in the DB if you are using other means of accessing data. 


=Conclusion=
ActibeJDBC makes it very easy to setup associations. If you work with a new schema, you just need to follow conventions (by including a logical foreign key into a child table). 
In cases when you already have an existing schema, ActiveJDBC allows to override conventions with simple annotations